package com.jcb.passbook.security.audit

import android.content.Context
import com.jcb.passbook.data.local.database.AppDatabase
import com.jcb.passbook.data.local.database.entities.AuditEntry
import com.jcb.passbook.data.local.database.entities.AuditEventType
import com.jcb.passbook.security.crypto.SecureMemoryUtils
import com.jcb.passbook.security.crypto.SessionManager
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import timber.log.Timber
import java.io.File
import java.io.RandomAccessFile
import java.time.Instant
import javax.crypto.Cipher
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.SecretKeySpec
import javax.inject.Inject
import javax.inject.Singleton

/**
 * ✅ REFACTORED: AuditJournalManager handles persistent journaling of audit entries
 * when the database is unavailable, ensuring no audit data is lost.
 *
 * ADDED METHODS FOR MasterAuditLogger INTEGRATION:
 * - recordAuditEvent() - Direct database logging with fallback to journal
 * - getAuditHistory() - Retrieve user audit history
 * - clearAllLogs() - Clear all audit logs (testing only)
 * - getAuditSummary() - Get audit statistics summary
 *
 * SECURITY FEATURES:
 * - Encrypted journal storage using ESK (Ephemeral Session Key)
 * - Automatic journal rotation when size limit reached
 * - Database-first approach with journal as fallback
 * - Tamper-evident audit trail with chain hashing
 */
@Singleton
class AuditJournalManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val sessionManager: SessionManager,
    private val secureMemoryUtils: SecureMemoryUtils
) {
    companion object {
        private const val JOURNAL_FILE_NAME = "audit_journal.log"
        private const val JOURNAL_BACKUP_NAME = "audit_journal_backup.log"
        private const val MAX_JOURNAL_SIZE_MB = 10
        private const val ENTRY_SEPARATOR = "\n---AUDIT_ENTRY---\n"
        private const val TAG = "AuditJournalManager"
    }

    private val journalFile = File(context.filesDir, JOURNAL_FILE_NAME)
    private val journalBackup = File(context.filesDir, JOURNAL_BACKUP_NAME)
    private val json = Json {
        ignoreUnknownKeys = true
        encodeDefaults = true
    }

    // Database instance - injected via setter to avoid circular dependency
    private var database: AppDatabase? = null

    /**
     * ✅ NEW: Set database instance for direct logging
     * Called by SecurityModule after database initialization
     */
    fun setDatabase(db: AppDatabase) {
        this.database = db
    }

    // =====================================================
    // NEW METHODS FOR MasterAuditLogger INTEGRATION
    // =====================================================

    /**
     * ✅ NEW: Record audit event to database with journal fallback
     * This is the primary method called by MasterAuditLogger
     */
    suspend fun recordAuditEvent(
        eventType: AuditEventType,
        message: String,
        timestamp: Instant,
        sessionId: String,
        userId: Long,
        metadata: Map<String, String> = emptyMap()
    ) {
        try {
            val entry = AuditEntry(
                id = 0L, // Auto-generated by Room
                userId = userId,
                action = message,
                eventType = eventType,
                timestamp = timestamp.toEpochMilli(),
                details = metadata.toString(),
                outcome = "SUCCESS", // Default outcome
                securityLevel = determineSecurityLevel(eventType),
                sessionId = sessionId,
                ipAddress = null, // Optional: Add IP tracking if needed
                deviceInfo = null, // Optional: Add device fingerprinting
                checksum = null, // Will be computed by AuditChainManager
                chainHash = null, // Will be set by AuditChainManager
                chainPrevHash = null // Will be set by AuditChainManager
            )

            // Try database first
            val db = database
            if (db != null) {
                try {
                    db.auditDao().insert(entry)
                    Timber.v("✅ Audit event recorded to database: ${eventType.name}")
                } catch (dbException: Exception) {
                    Timber.w(dbException, "Database write failed, falling back to journal")
                    writeToJournal(entry)
                }
            } else {
                // No database available, use journal
                Timber.d("Database not available, writing to journal")
                writeToJournal(entry)
            }

        } catch (e: Exception) {
            Timber.e(e, "❌ Failed to record audit event: ${eventType.name}")
        }
    }

    /**
     * ✅ NEW: Get audit history for a user
     * Returns list of AuditLogEntry compatible with MasterAuditLogger
     */
    suspend fun getAuditHistory(userId: Long, limit: Int = 100): List<AuditLogEntry> {
        return try {
            val db = database ?: return emptyList()

            // Query database for user's audit entries
            val entries = db.auditDao().getAuditEntriesForUser(userId)
                .kotlinx.coroutines.flow.first() // Get current value from Flow
                .take(limit)

            // Map to AuditLogEntry
            entries.map { entry ->
                AuditLogEntry(
                    id = entry.id,
                    userId = entry.userId,
                    eventType = entry.eventType,
                    message = entry.action,
                    timestamp = Instant.ofEpochMilli(entry.timestamp),
                    sessionId = entry.sessionId ?: "",
                    chainHash = entry.chainHash ?: ""
                )
            }
        } catch (e: Exception) {
            Timber.e(e, "Failed to get audit history for user $userId")
            emptyList()
        }
    }

    /**
     * ✅ NEW: Clear all audit logs
     * ⚠️ WARNING: Use only for testing! Never in production!
     */
    @Deprecated("Only for testing. Never call in production!")
    suspend fun clearAllLogs() {
        try {
            Timber.w("⚠️ CLEARING ALL AUDIT LOGS - This should NEVER happen in production!")

            // Clear database
            database?.auditDao()?.deleteAll()

            // Clear journal files
            clearJournal()

            Timber.d("✅ All audit logs cleared")
        } catch (e: Exception) {
            Timber.e(e, "Failed to clear all audit logs")
        }
    }

    /**
     * ✅ NEW: Get audit summary statistics
     * Returns aggregated data for dashboard displays
     */
    suspend fun getAuditSummary(): AuditSummary {
        return try {
            val db = database ?: return AuditSummary.empty()
            val currentSessionId = sessionManager.getSessionId()

            // Get total entries
            val totalEntries = db.auditDao().getTotalEntryCount()

            // Count entries for current session
            val entriesThisSession = db.auditDao().searchAuditEntries(
                userId = null,
                eventType = null,
                outcome = null,
                securityLevel = null,
                startTime = 0L,
                endTime = System.currentTimeMillis()
            ).kotlinx.coroutines.flow.first()
                .count { it.sessionId == currentSessionId }
                .toLong()

            // Count authentication attempts
            val authAttempts = db.auditDao().getAuditEntriesByType(AuditEventType.AUTHENTICATION_SUCCESS)
                .kotlinx.coroutines.flow.first().size +
                    db.auditDao().getAuditEntriesByType(AuditEventType.AUTHENTICATION_FAILURE)
                        .kotlinx.coroutines.flow.first().size

            // Count security violations
            val violations = db.auditDao().getAuditEntriesByType(AuditEventType.SECURITY_VIOLATION)
                .kotlinx.coroutines.flow.first().size

            // Get latest timestamp
            val lastTimestamp = db.auditDao().getLatestEntryTimestamp()
                ?.let { Instant.ofEpochMilli(it) }

            AuditSummary(
                totalEntries = totalEntries,
                entriesThisSession = entriesThisSession,
                authenticationAttempts = authAttempts.toLong(),
                securityViolations = violations.toLong(),
                lastAuditTimestamp = lastTimestamp
            )
        } catch (e: Exception) {
            Timber.e(e, "Failed to get audit summary")
            AuditSummary.empty()
        }
    }

    // =====================================================
    // EXISTING JOURNAL METHODS (PRESERVED)
    // =====================================================

    /**
     * Write audit entry to encrypted journal file
     */
    suspend fun writeToJournal(entry: AuditEntry) {
        try {
            val esk = sessionManager.getEphemeralSessionKey()
            if (esk == null) {
                // If no session key, write unencrypted (fallback for critical cases)
                writeUnencryptedEntry(entry)
                return
            }

            val entryJson = json.encodeToString(entry)
            val encryptedData = encryptData(entryJson, esk)

            synchronized(this) {
                // Check file size and rotate if needed
                if (journalFile.exists() && journalFile.length() > MAX_JOURNAL_SIZE_MB * 1024 * 1024) {
                    rotateJournal()
                }

                RandomAccessFile(journalFile, "rws").use { raf ->
                    raf.channel.lock().use { lock ->
                        raf.seek(raf.length())
                        raf.writeBytes("${System.currentTimeMillis()}:")
                        raf.writeBytes(android.util.Base64.encodeToString(encryptedData, android.util.Base64.NO_WRAP))
                        raf.writeBytes(ENTRY_SEPARATOR)
                    }
                }
            }

            Timber.v("Wrote audit entry to journal: ${entry.action}")

        } catch (e: Exception) {
            Timber.e(e, "Failed to write to audit journal")
            // Last resort - try unencrypted
            try {
                writeUnencryptedEntry(entry)
            } catch (fallbackException: Exception) {
                Timber.e(fallbackException, "Critical: Failed to write audit entry to journal even unencrypted")
            }
        }
    }

    /**
     * Write unencrypted entry (fallback for critical cases)
     */
    private fun writeUnencryptedEntry(entry: AuditEntry) {
        synchronized(this) {
            RandomAccessFile(journalFile, "rws").use { raf ->
                raf.channel.lock().use { lock ->
                    raf.seek(raf.length())
                    raf.writeBytes("${System.currentTimeMillis()}:UNENCRYPTED:")
                    raf.writeBytes(json.encodeToString(entry))
                    raf.writeBytes(ENTRY_SEPARATOR)
                }
            }
        }
    }

    /**
     * Recover audit entries from journal
     */
    suspend fun recoverFromJournal(): List<AuditEntry> {
        val recoveredEntries = mutableListOf<AuditEntry>()
        try {
            if (!journalFile.exists()) {
                return emptyList()
            }

            val content = journalFile.readText()
            val entries = content.split(ENTRY_SEPARATOR).filter { it.isNotBlank() }
            val esk = sessionManager.getEphemeralSessionKey()

            entries.forEach { entryData ->
                try {
                    val parts = entryData.split(":", limit = 3)
                    if (parts.size >= 2) {
                        val timestamp = parts[0].toLongOrNull()
                        val entryJson = when {
                            parts.size == 3 && parts[1] == "UNENCRYPTED" -> {
                                parts[2]
                            }
                            esk != null -> {
                                val encryptedData = android.util.Base64.decode(parts[1], android.util.Base64.NO_WRAP)
                                decryptData(encryptedData, esk)
                            }
                            else -> {
                                Timber.w("Cannot decrypt journal entry - no session key")
                                null
                            }
                        }

                        entryJson?.let { jsonStr ->
                            val entry = json.decodeFromString<AuditEntry>(jsonStr)
                            recoveredEntries.add(entry)
                        }
                    }
                } catch (e: Exception) {
                    Timber.w(e, "Failed to recover journal entry: ${entryData.take(100)}")
                }
            }

            Timber.i("Recovered ${recoveredEntries.size} entries from audit journal")

        } catch (e: Exception) {
            Timber.e(e, "Failed to recover from audit journal")
        }

        return recoveredEntries
    }

    /**
     * Clear the journal file after successful recovery
     */
    fun clearJournal() {
        try {
            synchronized(this) {
                if (journalFile.exists()) {
                    journalFile.delete()
                }
                if (journalBackup.exists()) {
                    journalBackup.delete()
                }
            }
            Timber.d("Cleared audit journal")
        } catch (e: Exception) {
            Timber.e(e, "Failed to clear audit journal")
        }
    }

    /**
     * Flush any pending writes to journal
     */
    suspend fun flushJournal() {
        // Force filesystem sync - journal writes are already synchronous
        try {
            if (journalFile.exists()) {
                RandomAccessFile(journalFile, "rws").use { raf ->
                    raf.fd.sync()
                }
            }
        } catch (e: Exception) {
            Timber.e(e, "Failed to flush journal")
        }
    }

    /**
     * Rotate journal when it gets too large
     */
    private fun rotateJournal() {
        try {
            if (journalBackup.exists()) {
                journalBackup.delete()
            }
            if (journalFile.exists()) {
                journalFile.renameTo(journalBackup)
            }
            Timber.d("Rotated audit journal")
        } catch (e: Exception) {
            Timber.e(e, "Failed to rotate journal")
        }
    }

    /**
     * Encrypt data with ESK
     */
    private fun encryptData(data: String, key: SecretKeySpec): ByteArray {
        val cipher = Cipher.getInstance("AES/GCM/NoPadding")
        cipher.init(Cipher.ENCRYPT_MODE, key)
        val iv = cipher.iv
        val encrypted = cipher.doFinal(data.toByteArray(Charsets.UTF_8))
        return iv + encrypted
    }

    /**
     * Decrypt data with ESK
     */
    private fun decryptData(encryptedData: ByteArray, key: SecretKeySpec): String? {
        return try {
            if (encryptedData.size <= 12) return null
            val iv = encryptedData.copyOfRange(0, 12)
            val encrypted = encryptedData.copyOfRange(12, encryptedData.size)
            val cipher = Cipher.getInstance("AES/GCM/NoPadding")
            cipher.init(Cipher.DECRYPT_MODE, key, GCMParameterSpec(128, iv))
            String(cipher.doFinal(encrypted), Charsets.UTF_8)
        } catch (e: Exception) {
            Timber.e(e, "Failed to decrypt journal data")
            null
        }
    }

    /**
     * ✅ NEW: Determine security level based on event type
     */
    private fun determineSecurityLevel(eventType: AuditEventType): String {
        return when (eventType) {
            AuditEventType.AUTHENTICATION_FAILURE,
            AuditEventType.SECURITY_VIOLATION,
            AuditEventType.UNAUTHORIZED_ACCESS -> "CRITICAL"

            AuditEventType.AUTHENTICATION_SUCCESS,
            AuditEventType.ENCRYPTION_OPERATION,
            AuditEventType.DATA_ACCESS -> "HIGH"

            AuditEventType.DATA_MODIFICATION,
            AuditEventType.CONFIGURATION_CHANGE -> "MEDIUM"

            else -> "LOW"
        }
    }

    /**
     * Get journal file size for monitoring
     */
    fun getJournalSize(): Long {
        return try {
            if (journalFile.exists()) journalFile.length() else 0L
        } catch (e: Exception) {
            0L
        }
    }

    /**
     * Check if journal exists and has content
     */
    fun hasJournalContent(): Boolean {
        return try {
            journalFile.exists() && journalFile.length() > 0
        } catch (e: Exception) {
            false
        }
    }
}

// =====================================================
// DATA CLASSES FOR MasterAuditLogger COMPATIBILITY
// =====================================================

/**
 * Audit log entry for retrieval
 * Matches MasterAuditLogger.AuditLogEntry structure
 */
data class AuditLogEntry(
    val id: Long,
    val userId: Long,
    val eventType: AuditEventType,
    val message: String,
    val timestamp: Instant,
    val sessionId: String,
    val chainHash: String
)

/**
 * Audit summary statistics
 * Matches MasterAuditLogger.AuditSummary structure
 */
data class AuditSummary(
    val totalEntries: Long = 0L,
    val entriesThisSession: Long = 0L,
    val authenticationAttempts: Long = 0L,
    val securityViolations: Long = 0L,
    val lastAuditTimestamp: Instant? = null
) {
    companion object {
        fun empty() = AuditSummary()
    }
}
